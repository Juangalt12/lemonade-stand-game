<!DOCTYPE html>
<html>
<head>
    <title>Fremont Bank Lemonade Stand Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Comic Neue', cursive;
            margin: 20px;
            background-image: linear-gradient(rgba(255,255,255,0.7), rgba(255,255,255,0.7)), 
                              url('https://wallsneedlove.com/cdn/shop/products/w0568_1s_Yellow-lemon-and-orange-sketch-wallpaper-Citrus-Grove_Repeating-Pattern-Sample-1.jpg?v=1734715911&width=1800');
            background-size: cover;
            background-position: center;
        }
        h1, h2 {
            color: #ff8c00;
            text-align: center;
            margin: 10px 0;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
        }
        label {
            display: inline-block;
            width: 300px;
            margin: 5px 0;
            color: #333;
        }
        input, select {
            margin: 5px 0;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-family: 'Comic Neue', cursive;
        }
        button {
            margin: 10px 0;
            padding: 12px 25px;
            background-color: #ffeb3b;
            color: #333;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 700;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        button:hover {
            background-color: #fdd835;
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        #inventory {
            background: #fffacd;
            border-color: #ffd700;
        }
        #results {
            background: #e0ffe0;
            border-color: #32cd32;
        }
        #history {
            background: #f0f8ff;
            border-color: #4682b4;
        }
        #costFeedback {
            background: #fafad2;
            border-color: #f4a460;
            margin-top: 10px;
            font-style: italic;
            color: #666;
        }
        #inventory, #results, #history, #costFeedback {
            padding: 15px;
            border: 2px solid;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .note { font-style: italic; color: #666; }
        .error { color: red; font-weight: bold; }
        .hint { color: #228b22; font-style: italic; }
        .warning { color: orange; font-weight: bold; }
        .highlight { font-weight: bold; font-size: 1.2em; }
        .final-results { font-weight: bold; font-size: 1.5em; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Lemonade Stand Game</h1>
        <p id="roundIndicator">Round 1 of 6</p>
        <p>Run your lemonade stand for 6 rounds to maximize profit! Manage your bankroll, inventory, and employees wisely.</p>
        <p class="note">Higher quality lemons, a good recipe, and special ingredients boost taste and sales in current and future rounds.</p>
        <div id="inventory">
            <h2>Inventory</h2>
            <p class="highlight">Bankroll: $<span id="bankroll">300.00</span></p>
            Lemons: <span id="lemons">None</span><br>
            Sugar: <span id="sugar">0</span>
        </div>
        <form id="inputForm">
            <h2>Buy Ingredients</h2>
            <label for="vendor">Vendor:</label>
            <select id="vendor" onchange="updateQualityOptions()">
                <option value="wholesale">Wholesale (min 25 lemons, in increments of 25)</option>
                <option value="topnotch">Top Notch (no min, always has Prime lemons)</option>
            </select><br>
            <label for="lemonQuality">Lemon Quality to Buy:</label>
            <select id="lemonQuality"></select><br>
            <label for="buyLemons">Number of lemons to buy:</label>
            <input type="number" id="buyLemons" min="0" value="0"><br>
            <label for="buySugar">Sugar cubes to buy ($0.10 each):</label>
            <input type="number" id="buySugar" min="0" value="0"><br>
            <label for="signs">Number of signs (0-5, $20 each):</label>
            <input type="number" id="signs" min="0" max="5" value="0"><br>
            <h2>Set Recipe</h2>
            <label for="lemonsPerCup">Lemons per cup (1-5):</label>
            <input type="number" id="lemonsPerCup" min="1" max="5" value="1"><br>
            <label for="sugarPerCup">Sugar cubes per cup (1-5):</label>
            <input type="number" id="sugarPerCup" min="1" max="5" value="1"><br>
            <label for="specialIngredient">Special Ingredient:</label>
            <select id="specialIngredient">
                <option value="none">None (Simple Cup)</option>
                <option value="mint">Mint ($0.30 per cup)</option>
                <option value="basil">Basil ($0.40 per cup)</option>
                <option value="turbinado">Turbinado Sugar ($0.20 per cup)</option>
                <option value="ginger">Ginger ($0.50 per cup)</option>
                <option value="lavender">Lavender ($0.60 per cup)</option>
            </select><br>
            <h2>Hire Employees</h2>
            <p class="note">Intern ($75, sells 50 cups), Experienced ($150, sells 120 cups), Manager ($150, sells 50 cups + boosts others by 30%). At least one employee required.</p>
            <label for="interns">Number of Interns:</label>
            <input type="number" id="interns" min="0" value="0"><br>
            <label for="experienced">Number of Experienced Salespeople:</label>
            <input type="number" id="experienced" min="0" value="0"><br>
            <label for="managers">Number of Managers:</label>
            <input type="number" id="managers" min="0" value="0"><br>
            <button type="button" onclick="processRound()">Submit Round</button>
        </form>
        <div id="costFeedback" class="note"></div>
        <div id="errors" class="error"></div>
        <div id="results"></div>
        <div id="history">
            <h2>Round History</h2>
            <span id="historyContent">No rounds completed yet.</span>
        </div>
        <button id="restart" style="display:none;" onclick="restartGame()">Restart Game</button>
    </div>

    <script>
        const INITIAL_BANKROLL = 300;
        const MIN_WHOLESALE_LEMONS = 25;
        const WHOLESALE_INCREMENT = 25;
        const SUGAR_COST = 0.10;
        const SIGN_COST = 20;
        const PRICE_PER_UNIT = 10;
        const MAX_ROUNDS = 6;
        const QUALITY_NAMES = {1: "Irregular", 2: "Average", 3: "Good", 4: "Prime"};
        const BASE_CUSTOMERS = 100;
        const SPOILAGE_RATE = 0.1;
        const SPOILAGE_COST_PER_LEMON = 0.1;
        const SPECIAL_INGREDIENTS = {
            none: { name: "None", cost: 0, idealLemons: 3, idealSugar: 2 },
            mint: { name: "Mint", cost: 0.3, idealLemons: 2, idealSugar: 3 },
            basil: { name: "Basil", cost: 0.4, idealLemons: 1, idealSugar: 4 },
            turbinado: { name: "Turbinado Sugar", cost: 0.2, idealLemons: 3, idealSugar: 2 },
            ginger: { name: "Ginger", cost: 0.5, idealLemons: 2, idealSugar: 2 },
            lavender: { name: "Lavender", cost: 0.6, idealLemons: 1, idealSugar: 3 }
        };
        const EMPLOYEE_TYPES = {
            intern: { wage: 75, capacity: 50 },
            experienced: { wage: 150, capacity: 120 },
            manager: { wage: 150, capacity: 50, boost: 0.3 }
        };

        const gameState = {
            round: 1,
            totalProfit: 0,
            cumulativeRevenue: 0,
            cumulativeExpenses: 0,
            bankroll: INITIAL_BANKROLL,
            wordOfMouthBonus: 0,
            lemonsInventory: {1: 0, 2: 0, 3: 0, 4: 0},
            sugarInventory: 0,
            vendorOffers: {},
            history: [],
            poorQualityPenaltyNextRound: false,
            previousRevenue: 0
        };

        const elements = {
            roundIndicator: document.getElementById('roundIndicator'),
            bankroll: document.getElementById('bankroll'),
            lemons: document.getElementById('lemons'),
            sugar: document.getElementById('sugar'),
            errors: document.getElementById('errors'),
            results: document.getElementById('results'),
            historyContent: document.getElementById('historyContent'),
            inputForm: document.getElementById('inputForm'),
            restart: document.getElementById('restart'),
            costFeedback: document.getElementById('costFeedback')
        };

        initializeGame();

        function initializeGame() {
            gameState.round = 1;
            gameState.totalProfit = 0;
            gameState.cumulativeRevenue = 0;
            gameState.cumulativeExpenses = 0;
            gameState.bankroll = INITIAL_BANKROLL;
            gameState.wordOfMouthBonus = 0;
            gameState.lemonsInventory = {1: 0, 2: 0, 3: 0, 4: 0};
            gameState.sugarInventory = 0;
            gameState.history = [];
            gameState.poorQualityPenaltyNextRound = false;
            gameState.previousRevenue = 0;
            generateVendorOffers();
            updateInventoryDisplay();
            updateQualityOptions();
            updateCostFeedback();
        }

        function generateVendorOffers() {
            const qualities = [1, 2, 3, 4];
            const topNotchOther = shuffle(qualities.slice(0,3)).slice(0,2);
            const topNotchQualities = [4, ...topNotchOther];
            gameState.vendorOffers.topnotch = topNotchQualities.map(q => ({
                quality: q,
                name: QUALITY_NAMES[q],
                price: (0.5 * q).toFixed(2)
            }));
            const wholesaleQualities = shuffle(qualities).slice(0,3);
            gameState.vendorOffers.wholesale = wholesaleQualities.map(q => ({
                quality: q,
                name: QUALITY_NAMES[q],
                price: (0.5 * q * 0.7).toFixed(2)
            }));
        }

        function updateQualityOptions() {
            const vendor = document.getElementById('vendor').value;
            const offers = gameState.vendorOffers[vendor];
            const select = document.getElementById('lemonQuality');
            select.innerHTML = '';
            offers.forEach(offer => {
                const option = document.createElement('option');
                option.value = offer.quality;
                option.text = `${offer.name} (Quality ${offer.quality}, $${offer.price} each)`;
                select.add(option);
            });
            updateCostFeedback();
        }

        function updateInventoryDisplay() {
            let lemonsStr = '';
            for (let q in gameState.lemonsInventory) {
                if (gameState.lemonsInventory[q] > 0) {
                    lemonsStr += `${QUALITY_NAMES[q]}: ${gameState.lemonsInventory[q]}<br>`;
                }
            }
            elements.lemons.innerHTML = lemonsStr || 'None';
            elements.sugar.textContent = gameState.sugarInventory;
            elements.bankroll.textContent = gameState.bankroll.toFixed(2);
        }

        function shuffle(array) {
            return array.sort(() => Math.random() - 0.5);
        }

        function calculateAverageQuality() {
            let totalQuality = 0;
            let totalLemons = 0;
            for (let q in gameState.lemonsInventory) {
                const quantity = gameState.lemonsInventory[q];
                if (quantity > 0) {
                    totalQuality += parseInt(q) * quantity;
                    totalLemons += quantity;
                }
            }
            return totalLemons > 0 ? totalQuality / totalLemons : 0;
        }

        function updateCostFeedback() {
            const vendor = document.getElementById('vendor').value;
            const qualitySelect = document.getElementById('lemonQuality');
            const qualityIndex = qualitySelect.selectedIndex;
            if (qualityIndex === -1) return;
            const offer = gameState.vendorOffers[vendor][qualityIndex];
            const price = parseFloat(offer.price);
            const buyLemons = parseInt(document.getElementById('buyLemons').value) || 0;
            const buySugar = parseInt(document.getElementById('buySugar').value) || 0;
            const signs = parseInt(document.getElementById('signs').value) || 0;
            const interns = parseInt(document.getElementById('interns').value) || 0;
            const experienced = parseInt(document.getElementById('experienced').value) || 0;
            const managers = parseInt(document.getElementById('managers').value) || 0;

            const costLemons = buyLemons * price;
            const costSugar = buySugar * SUGAR_COST;
            const costSigns = signs * SIGN_COST;
            const costEmployees = (interns * EMPLOYEE_TYPES.intern.wage) + 
                                (experienced * EMPLOYEE_TYPES.experienced.wage) + 
                                (managers * EMPLOYEE_TYPES.manager.wage);
            const totalPurchaseCost = costLemons + costSugar + costSigns + costEmployees;
            const remainingBankroll = gameState.bankroll - totalPurchaseCost;

            elements.costFeedback.innerHTML = `<span class="highlight">Purchases will cost $${totalPurchaseCost.toFixed(2)}, leaving $${remainingBankroll.toFixed(2)} in bankroll.</span> Additional costs for special ingredients will apply.`;
            elements.costFeedback.className = remainingBankroll < 0 ? 'warning' : 'note';
        }

        function getRecipeAdvice(lemonsPerCup, sugarPerCup, specialIngredient) {
            const ideal = SPECIAL_INGREDIENTS[specialIngredient];
            const idealLemons = ideal.idealLemons;
            const idealSugar = ideal.idealSugar;
            if (lemonsPerCup === idealLemons && sugarPerCup === idealSugar) {
                return "Customers love this recipe!";
            }
            let advice = "Customers say ";
            if (lemonsPerCup < idealLemons && sugarPerCup < idealSugar) {
                advice += "more sugar and more lemons";
            } else if (lemonsPerCup > idealLemons && sugarPerCup > idealSugar) {
                advice += "less sugar and fewer lemons";
            } else if (lemonsPerCup < idealLemons && sugarPerCup > idealSugar) {
                advice += "less sugar and more lemons";
            } else if (lemonsPerCup > idealLemons && sugarPerCup < idealSugar) {
                advice += "more sugar and fewer lemons";
            } else if (lemonsPerCup < idealLemons) {
                advice += "more lemons";
            } else if (lemonsPerCup > idealLemons) {
                advice += "fewer lemons";
            } else if (sugarPerCup < idealSugar) {
                advice += "more sugar";
            } else if (sugarPerCup > idealSugar) {
                advice += "less sugar";
            }
            advice += " for this recipe.";
            return advice;
        }

        function processRound() {
            elements.errors.innerHTML = '';
            try {
                const vendor = document.getElementById('vendor').value;
                const qualitySelect = document.getElementById('lemonQuality');
                const qualityIndex = qualitySelect.selectedIndex;
                const offer = gameState.vendorOffers[vendor][qualityIndex];
                const buyQuality = offer.quality;
                const price = parseFloat(offer.price);
                const buyLemons = parseInt(document.getElementById('buyLemons').value);
                const buySugar = parseInt(document.getElementById('buySugar').value);
                const signs = parseInt(document.getElementById('signs').value);
                const lemonsPerCup = parseInt(document.getElementById('lemonsPerCup').value);
                const sugarPerCup = parseInt(document.getElementById('sugarPerCup').value);
                const specialIngredient = document.getElementById('specialIngredient').value;
                const interns = parseInt(document.getElementById('interns').value);
                const experienced = parseInt(document.getElementById('experienced').value);
                const managers = parseInt(document.getElementById('managers').value);

                if (vendor === 'wholesale' && buyLemons > 0 && (buyLemons < MIN_WHOLESALE_LEMONS || buyLemons % WHOLESALE_INCREMENT !== 0)) {
                    throw new Error(`For Wholesale, number of lemons must be at least ${MIN_WHOLESALE_LEMONS} and in multiples of ${WHOLESALE_INCREMENT}.`);
                }
                if (buyLemons < 0 || buySugar < 0 || signs < 0 || signs > 5 || 
                    lemonsPerCup < 1 || lemonsPerCup > 5 || sugarPerCup < 1 || sugarPerCup > 5 ||
                    interns < 0 || experienced < 0 || managers < 0) {
                    throw new Error('Invalid input values.');
                }
                if (interns + experienced + managers === 0) {
                    throw new Error('You must hire at least one employee to sell lemonade.');
                }

                const costLemons = buyLemons * price;
                const costSugar = buySugar * SUGAR_COST;
                const costSigns = signs * SIGN_COST;
                const costEmployees = (interns * EMPLOYEE_TYPES.intern.wage) + 
                                    (experienced * EMPLOYEE_TYPES.experienced.wage) + 
                                    (managers * EMPLOYEE_TYPES.manager.wage);
                const totalCosts = costLemons + costSugar + costSigns + costEmployees;

                if (gameState.bankroll < totalCosts) {
                    throw new Error('Insufficient funds.');
                }

                gameState.bankroll -= totalCosts;
                gameState.cumulativeExpenses += totalCosts;

                gameState.lemonsInventory[buyQuality] = (gameState.lemonsInventory[buyQuality] || 0) + buyLemons;
                gameState.sugarInventory += buySugar;

                const effectiveQuality = gameState.round === 1 ? buyQuality : calculateAverageQuality();
                if (effectiveQuality === 0) {
                    throw new Error('No lemons available.');
                }
                const totalLemons = Object.values(gameState.lemonsInventory).reduce((sum, qty) => sum + qty, 0);
                if (totalLemons < lemonsPerCup || gameState.sugarInventory < sugarPerCup) {
                    throw new Error('Not enough lemons or sugar to produce even one cup.');
                }

                const ideal = SPECIAL_INGREDIENTS[specialIngredient];
                const lemonsDiff = Math.abs(ideal.idealLemons - lemonsPerCup);
                const sugarDiff = Math.abs(ideal.idealSugar - sugarPerCup);
                const recipeAccuracy = Math.max(1 - (lemonsDiff + sugarDiff) / 10, 0);
                const lemonQualityFactor = effectiveQuality / 4;
                let tasteScore = lemonQualityFactor * recipeAccuracy;
                if (lemonsPerCup === ideal.idealLemons && sugarPerCup === ideal.idealSugar) {
                    tasteScore += 0.1;
                }
                tasteScore = Math.min(tasteScore, 1.0);

                const maxUnitsFromLemons = Math.floor(totalLemons / lemonsPerCup);
                const maxUnitsFromSugar = Math.floor(gameState.sugarInventory / sugarPerCup);
                const unitsProduced = Math.min(maxUnitsFromLemons, maxUnitsFromSugar);

                const specialIngCost = unitsProduced * SPECIAL_INGREDIENTS[specialIngredient].cost;
                gameState.bankroll -= specialIngCost;
                gameState.cumulativeExpenses += specialIngCost;

                const lemonsUsed = unitsProduced * lemonsPerCup;
                let remainingLemons = lemonsUsed;
                for (let q in gameState.lemonsInventory) {
                    if (remainingLemons > 0 && gameState.lemonsInventory[q] > 0) {
                        const proportion = gameState.lemonsInventory[q] / totalLemons;
                        const lemonsToUse = Math.min(Math.floor(proportion * lemonsUsed), remainingLemons, gameState.lemonsInventory[q]);
                        gameState.lemonsInventory[q] -= lemonsToUse;
                        remainingLemons -= lemonsToUse;
                    }
                }
                gameState.sugarInventory -= unitsProduced * sugarPerCup;

                const signEffect = signs * 20;
                const wordOfMouthEffect = Math.floor(tasteScore * 50);
                const customerDemand = BASE_CUSTOMERS + signEffect + wordOfMouthEffect;

                let nonManagerCapacity = (interns * EMPLOYEE_TYPES.intern.capacity) + (experienced * EMPLOYEE_TYPES.experienced.capacity);
                const managerCapacity = managers * EMPLOYEE_TYPES.manager.capacity;
                const totalCapacity = managers > 0 ? Math.floor(nonManagerCapacity * (1 + EMPLOYEE_TYPES.manager.boost)) + managerCapacity : nonManagerCapacity + managerCapacity;

                const potentialSales = Math.floor(customerDemand * tasteScore);
                let baseSales = Math.min(unitsProduced, potentialSales);

                const currentPenalty = (tasteScore < 0.5 || effectiveQuality < 2) ? 0.875 : 1.0;
                baseSales = Math.floor(baseSales * currentPenalty);

                if (gameState.poorQualityPenaltyNextRound) {
                    baseSales = Math.floor(baseSales * 0.875);
                    gameState.poorQualityPenaltyNextRound = false;
                }

                const sales = Math.min(baseSales, totalCapacity);

                gameState.poorQualityPenaltyNextRound = tasteScore < 0.5 || effectiveQuality < 2;

                const revenue = sales * PRICE_PER_UNIT;
                gameState.bankroll += revenue;
                gameState.cumulativeRevenue += revenue;

                let totalSpoiled = 0;
                for (let q in gameState.lemonsInventory) {
                    const spoiled = Math.floor(gameState.lemonsInventory[q] * SPOILAGE_RATE);
                    totalSpoiled += spoiled;
                    gameState.lemonsInventory[q] -= spoiled;
                }
                const spoilageCost = totalSpoiled * SPOILAGE_COST_PER_LEMON;
                gameState.bankroll -= spoilageCost;
                gameState.cumulativeExpenses += spoilageCost;

                const profit = revenue - totalCosts - specialIngCost - spoilageCost;
                gameState.totalProfit += profit;

                const revenueGrowth = gameState.round === 1 || gameState.previousRevenue === 0 ? 'N/A' : (((revenue - gameState.previousRevenue) / gameState.previousRevenue) * 100).toFixed(2) + '%';
                const profitMargin = revenue > 0 ? ((profit / revenue) * 100).toFixed(2) + '%' : 'N/A';
                const efficiencyRatio = revenue > 0 ? (((totalCosts + specialIngCost + spoilageCost) / revenue) * 100).toFixed(2) + '%' : 'N/A';

                const recipeAdvice = getRecipeAdvice(lemonsPerCup, sugarPerCup, specialIngredient);
                const nextWordOfMouth = Math.floor(tasteScore * 50);
                let signsFeedback = `Signs brought in ${signEffect} extra customers.`;
                let wordOfMouthFeedback = `Word of mouth from last round added ${gameState.wordOfMouthBonus} customers. Next round's word of mouth will add ${nextWordOfMouth} customers.`;
                let salesLimitReason = sales === baseSales ? 'sales capacity' : sales === unitsProduced ? 'production' : 'demand';
                let additionalFeedback = '';

                if (salesLimitReason === 'demand' && signs < 5) {
                    additionalFeedback += '<p class="hint">More signs could attract more customers!</p>';
                }
                if (tasteScore < 0.8) {
                    additionalFeedback += '<p class="hint">Better taste could increase word of mouth next round!</p>';
                }
                if (gameState.poorQualityPenaltyNextRound) {
                    additionalFeedback += '<p class="hint">Poor quality or taste this round will reduce next round\'s sales by 12.5%.</p>';
                }

                const isFinalRound = gameState.round === MAX_ROUNDS;
                const roundHeader = isFinalRound ? '<h2 class="final-results">FINAL RESULTS</h2>' : `<h2>Round ${gameState.round} Results</h2>`;
                elements.results.innerHTML = `
                    ${roundHeader}
                    <p>Taste Score: ${tasteScore.toFixed(2)} (Max 1.0 with ideal quality and recipe match)</p>
                    <p>Units Produced: ${unitsProduced}</p>
                    <p>Customer Demand: ${customerDemand} (${signsFeedback}, Word of Mouth: ${wordOfMouthEffect})</p>
                    <p>Sales Capacity: ${totalCapacity} cups</p>
                    <p>Sales: ${sales} cups (limited by ${salesLimitReason})</p>
                    <p>Revenue: $${revenue.toFixed(2)}</p>
                    <p>Revenue Growth: ${revenueGrowth}</p>
                    <p class="highlight">Expenses: $${(totalCosts + specialIngCost + spoilageCost).toFixed(2)} (Lemons: $${costLemons.toFixed(2)}, Sugar: $${costSugar.toFixed(2)}, Signs: $${costSigns.toFixed(2)}, Employees: $${costEmployees.toFixed(2)}, Special Ingredient: $${specialIngCost.toFixed(2)}, Spoilage: $${spoilageCost.toFixed(2)})</p>
                    <p>Profit this round: $${profit.toFixed(2)}</p>
                    <p>Profit Margin: ${profitMargin}</p>
                    <p>Efficiency Ratio: ${efficiencyRatio} (Expenses as a percentage of revenue, lower is better)</p>
                    <p>Total Profit: $${gameState.totalProfit.toFixed(2)}</p>
                    <p class="hint">${recipeAdvice}</p>
                    ${additionalFeedback}
                `;

                gameState.wordOfMouthBonus = nextWordOfMouth;
                gameState.history.push({ round: gameState.round, revenue: revenue.toFixed(2), profit: profit.toFixed(2), sales, profitMargin, efficiencyRatio });
                gameState.previousRevenue = revenue;

                elements.historyContent.innerHTML = gameState.history.map(h => `Round ${h.round}: Revenue $${h.revenue}, Profit $${h.profit}, Sales ${h.sales}, Profit Margin ${h.profitMargin}, Efficiency Ratio ${h.efficiencyRatio}`).join('<br>');

                gameState.round++;
                if (gameState.round <= MAX_ROUNDS) {
                    generateVendorOffers();
                    updateQualityOptions();
                    updateInventoryDisplay();
                    elements.roundIndicator.textContent = `Round ${gameState.round} of ${MAX_ROUNDS}`;
                } else {
                    endGame();
                }
                updateCostFeedback();
            } catch (error) {
                elements.errors.innerHTML = error.message;
            }
        }

        function endGame() {
            const cumulativeProfitMargin = gameState.cumulativeRevenue > 0 ? ((gameState.totalProfit / gameState.cumulativeRevenue) * 100).toFixed(2) + '%' : 'N/A';
            const overallEfficiencyRatio = gameState.cumulativeRevenue > 0 ? ((gameState.cumulativeExpenses / gameState.cumulativeRevenue) * 100).toFixed(2) + '%' : 'N/A';
            elements.results.innerHTML += `
                <p class="highlight">Total Profit: $${gameState.totalProfit.toFixed(2)}</p>
                <p class="highlight">Cumulative Revenue: $${gameState.cumulativeRevenue.toFixed(2)}</p>
                <p class="highlight">Cumulative Profit Margin: ${cumulativeProfitMargin}</p>
                <p class="highlight">Overall Efficiency Ratio: ${overallEfficiencyRatio} (Expenses as a percentage of revenue, lower is better)</p>
            `;
            elements.inputForm.style.display = 'none';
            elements.restart.style.display = 'block';
        }

        function restartGame() {
            initializeGame();
            elements.inputForm.style.display = 'block';
            elements.results.innerHTML = '';
            elements.errors.innerHTML = '';
            elements.restart.style.display = 'none';
            updateInventoryDisplay();
            updateCostFeedback();
        }

        const costInputs = ['vendor', 'lemonQuality', 'buyLemons', 'buySugar', 'signs', 'interns', 'experienced', 'managers'];
        costInputs.forEach(id => {
            const input = document.getElementById(id);
            input.addEventListener('change', updateCostFeedback);
            if (input.type === 'number') {
                input.addEventListener('input', updateCostFeedback);
            }
        });

        updateQualityOptions();
        updateCostFeedback();
    </script>
</body>
</html>
